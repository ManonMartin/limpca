---
title: "Application of the LMWiRe package on the UCH dataset"
author: "Benaiche Nadia"
date: 2022-01-09
package: LMWiRe
output:
  BiocStyle::html_document:
    toc: yes
    toc_depth: 3
    toc_float: yes
vignette: >
   %\VignetteIndexEntry{Analysis of the UCH dataset with LMWiRe}
   %\VignetteEncoding{UTF-8}
   %\VignetteEngine{knitr::rmarkdown}
editor_options: 
   chunk_output_type: console
references:
- id: Thiel2017
  title: ASCA+ and APCA+ Extensions of ASCA and APCA in the analysis of unbalanced multifactorial designs
  author:
  - family: Thiel
    given: Michel
  - family: Feraud
    given: Baptiste
  - family: Govaerts
    given: Bernadette
  container-title: Journal of Chemometrics
  type: article-journal
  issued:
    year: 2017
- id: Guisset2019
  title: Comparison of PARAFASCA, AComDim, and AMOPLS approaches in the multivariate GLM modelling of multi-factorial designs
  author:
  - family: Guisset
    given: Severine
  - family: Martin
    given: Manon
  - family: Govaerts
    given: Bernadette
  container-title: Chemometrics and Intelligent Laboratory Systems
  type: article-journal
  issued:
    year: 2019
---

```{r Setup,include=FALSE}
require(knitr)
require(pander)
require(patchwork)
require(ggplot2)
knitr::opts_chunk$set(message=FALSE,warning=FALSE,comment=NA)

```


# Introduction

The purpose of this vignette is to show the possibilities offered by the LMWiRe package. LMWiRe stands for Linear Models for Wide Responses. This package was created to analyse models with wide responses and a multi-factor design of experiment. The model used in this example is a three-way ANOVA with fixed effects. This document presents all the usual steps of the analysis, from importing the data to visualising the results. The methods used come from the articles of @Thiel2017 and @Guisset2019.

# Installation

The package is actually in its development stage and is available on GitHub at the url: <https://github.com/bgovaerts/LMWiRe/tree/develop>. It can be installed via the `devtools::install_github()` function. The package needs to be loaded afterwards.


```{r Install, results=FALSE, message=FALSE}

# devtools::install_github("bgovaerts/LMWiRe@develop", force = TRUE)

library("LMWiRe")

```

# Data importation

Before any analysis, the `UCH` data set needs to be loaded. The LMWiRe package contains the data set and it can be loaded with the `data()` function. The `load()` function is also useful to import your own data.

```{r Data Importation}

data("UCH")

```

# Data exploration

The UCH (Urine-Citrate-Hippurate) data set comes from \textit{Rousseau et al.}. It contains 3 elements: an `outcomes` matrix with 34 observations of 600 response variables representing the spectra from the H-NMR spectroscopy, a `design` matrix with 34 observations and 4 explanatory variables and a formula for the GLM model used. For the purpose of this example, only 3 variables will be studied.

## Design

The design matrix contains the information about each observation for the four variables: Hippurate, Citrate, Day and Time. Only 3 of these variables are used in the model. The function `plotDesign` is useful to observe the design.

```{r Design}

pander(head(UCH$design))

plotDesign(design = UCH$design, x = "Hippurate", 
           y = "Citrate", rows = "Time",
           title = "Design of the UCH dataset")

```


## Outcomes visualisation

The 600 response variables are the spectrum of the H-NMR for each observations. 

```{r Spectrum visualization}
p1 <- plotLine(Y = UCH$outcomes,
         title = "H-NMR spectrum",
         rows = c(3),
         xlab = "ppm",
         ylab = "Intensity")
p1 + annotate("rect", xmin=7.458, xmax=7.935, ymin=-Inf, ymax=Inf, alpha=0.2, fill="yellowgreen")+
  annotate("rect", xmin=3.881, xmax=4.041, ymin=-Inf, ymax=Inf, alpha=0.2, fill="yellowgreen")+
  annotate("rect", xmin=2.509, xmax=2.709, ymin=-Inf, ymax=Inf, alpha=0.2, fill="tomato") 

```


Variables (ppm) visualisation

```{r}
# xy corresponds to citrate (453) and hippurate peaks (369)

plotScatter(Y = UCH$outcomes,
            xy = c(453, 369),
            design = UCH$design,
            color = "Hippurate", 
            shape = "Citrate")
# Or
plotScatter(Y = UCH$outcomes,
            xy = c("2.6092056","3.9811536"),
            design = UCH$design,
            color = "Hippurate", 
            shape = "Citrate")
```

```{r}
plotScatterM(Y = UCH$outcomes, cols = c(133, 145, 150, 369, 453), design = UCH$design,
             varname.colorup = "Hippurate", varname.colordown = "Citrate")
```

```{r}
plotMeans(Y = UCH$outcomes,
          design = UCH$design,
          cols = c(453,396),
          x = "Hippurate",
          z = "Time",
          w = "Citrate",
          ylab = "Intensity")
```

## Principal Component Analysis

The function `pcaBySvd` is useful to compute a PCA decomposition of the `outcomes` matrix. The `scores` and `loadings` can then be plotted with the functions `pcaScorePlot` and `pcaLoadingPlot`.

```{r PCA}

ResPCA = pcaBySvd(UCH$outcomes)
pcaScreePlot(ResPCA, nPC = 6) + ggplot2::geom_bar(stat = "identity", fill = "cadetblue4")

```

```{r Scores}

pcaScorePlot(resPcaBySvd = ResPCA, axes = c(1,2), 
             title = "PCA scores plot: PC1 and PC2", 
             design = UCH$design,
             color = "Hippurate", shape = "Citrate",
             points_labs_rn = FALSE)

pcaScorePlot(resPcaBySvd = ResPCA, axes = c(1,2), 
             title = "PCA scores plot: PC1 and PC2", 
             design = UCH$design,
             color = "Time", shape = "Hippurate",
             points_labs_rn = FALSE)

pcaScorePlot(resPcaBySvd = ResPCA, axes = c(3,4), 
             title = "PCA scores plot: PC3 and PC4", 
             design = UCH$design,
             color = "Time", shape = "Citrate",
             points_labs_rn = FALSE)

```

```{r Loadings}

p2 <- pcaLoadingPlot(resPcaBySvd = ResPCA, axes = c(1,2), 
               title = "PCA loadings plot UCH", xlab = "ppm", ylab = "Intensity")

p2 + annotate("rect", xmin=7.458, xmax=7.935, ymin=-Inf, ymax=Inf, alpha=0.2, fill="yellowgreen") +
 annotate("rect", xmin=3.881, xmax=4.041, ymin=-Inf, ymax=Inf, alpha=0.2, fill="yellowgreen") +
 annotate("rect", xmin=2.509, xmax=2.709, ymin=-Inf, ymax=Inf, alpha=0.2, fill="tomato") 

```

# GLM decomposition

The formula of the ANOVA-GLM model used in this analysis is:

```{r Formula}
UCH$formula
```

The analysis consists of decomposing the model matrix into effect matrices and performing a PCA on each of the effect matrices. Here we have 34 observations, 3 categorical explanatory variables, 600 response variables and 8 model terms.

The first step is to make the model matrix from the matrix of the experimental design. Each explanatory variable is reencoded with multiple binary variables. The model matrix is a \emph(34xK) with K being the total number of new binary variables.

The function `lmwModelMatrix()` encodes the design matrix as a model matrix.

```{r ModelMatrix}

resLmwModelMatrix = lmwModelMatrix(UCH)
pander::pander(head(resLmwModelMatrix$modelMatrix))
```

The model matrix can then be decomposed into effect matrices for every model terms with the function `lmwEffectMatrices()`.

```{r EffectMatrices}

resLmwEffectMatrices = lmwEffectMatrices(resLmwModelMatrix)

# Print effect contributions
pander(resLmwEffectMatrices$variationPercentages)
resLmwEffectMatrices$varPercentagesPlot + ggplot2::geom_bar(stat = "identity", fill = "cadetblue4")

```

## Bootstrap tests and quantification of effects importance

We can use a parametric bootstrap test to determine whether an effect is significant or not. We suggest the function `lmwBootstrapTests()`. The type III SS represents the percentage of variation of the response matrix Y explained by each model effect in the GLM decomposition.

```{r Bootstrap}

resLmwBootstrapTests = lmwBootstrapTests(resLmwEffectMatrices = resLmwEffectMatrices, nboot=100)

# Print Pvalue
pander::pander(t(resLmwBootstrapTests$resultsTable))

```

# ASCA/ASCA-E/APCA

These methods allow to represent the information from the effect matrices in a space of reduced dimensions. The function `lmwPcaEffects()` have a method argument to define which method to use.

## ASCA

The ASCA method performs PCAs on the pure effect matrices.

```{r ASCA PCA}
resASCA = lmwPcaEffects(resLmwEffectMatrices = resLmwEffectMatrices, method="ASCA",
                        combineEffects = list(c("Hippurate", "Time", "Hippurate:Time")))
```

### Contributions

The contributions from each effect and their components are estimated and reported in tables with the function `lmwContributions()`. Moreover the function also output barplots with the ordered contributions.

```{r ASCA Contrib}
resLmwContributions = lmwContributions(resASCA)

pander::pander(resLmwContributions$totalContribTable)
pander::pander(resLmwContributions$effectTable)
pander::pander(resLmwContributions$contribTable)
pander::pander(resLmwContributions$combinedEffectTable)

resLmwContributions$plotContrib + ggplot2::geom_bar(stat = "identity", fill = "cadetblue4")
```

### Scores Plot

The score matrices are then represented on two components with the function `lmwScorePlot()`.

```{r ASCA ScoresXY}
lmwScorePlot(resASCA, effectNames = "Hippurate", color = "Hippurate", shape = "Hippurate")
lmwScorePlot(resASCA, effectNames = "Citrate", color = "Citrate", shape = "Citrate")
lmwScorePlot(resASCA, effectNames = "Time", color = "Time", shape = "Time")
lmwScorePlot(resASCA, effectNames = "Hippurate:Time", color = "Hippurate", shape = "Time")
lmwScorePlot(resASCA, effectNames = "Hippurate+Time+Hippurate:Time", color = "Hippurate", shape = "Time")
lmwScorePlot(resASCA, effectNames = "Hippurate+Time+Hippurate:Time", color = "Hippurate", shape = "Time", axes = c(3,4))
```

Finally we can represent the scores with a matrix of plots. This graph allows to observe multiple variables simultaneously.

```{r ASCA ScoresMatrix}
lmwScoreScatterPlotM(resASCA,
                     modelAbbrev = TRUE,
                     varname.colorup = "Citrate",
                     vec.colorup = c("royalblue","yellowgreen","lightcoral"),
                     varname.colordown  = "Time",
                     vec.colordown = c("cadetblue4","deeppink4"),
                     varname.pchup="Hippurate",
                     vec.pchup = c(4,16,2),
                     varname.pchdown="Time",
                     vec.pchdown = c(1,3), title = "ASCA scores scatterplot matrix")
```

### Effects plot

```{r ASCA effects}
lmwEffectPlot(resASCA, effectName = "Hippurate", x = "Hippurate")
lmwEffectPlot(resASCA, effectName = "Citrate", x = "Citrate")
lmwEffectPlot(resASCA, effectName = "Time", x = "Time")
lmwEffectPlot(resASCA, effectName = "Hippurate:Time", x = "Hippurate", z = "Time")
lmwEffectPlot(resASCA, effectName = "Hippurate:Time", x = "Time", z = "Hippurate")
lmwEffectPlot(resASCA, effectName = "Hippurate+Time+Hippurate:Time", x = "Hippurate", z = "Time")
lmwEffectPlot(resASCA, effectName = "Hippurate+Time+Hippurate:Time", axes = c(1:3), x = "Time", z = "Hippurate")
```


### Loadings plot

```{r ASCA loadings}

resLoadASCA <- lmwLoadingPlot(resASCA, effectNames = c("Hippurate", "Citrate","Time",
                                        "Hippurate:Time","Hippurate+Time+Hippurate:Time"), 
                              axes = 1, xlab = "ppm")
resLoadASCA[[1]] + annotate("rect", xmin=7.458, xmax=7.935, ymin=-Inf, ymax=Inf, alpha=0.2, fill="yellowgreen") + annotate("rect", xmin=3.881, xmax=4.041, ymin=-Inf, ymax=Inf, alpha=0.2, fill="yellowgreen")

resLoadASCA[[2]] + annotate("rect", xmin=2.509, xmax=2.709, ymin=-Inf, ymax=Inf, alpha=0.2, fill="tomato")

resLoadASCA[[3]] + annotate("rect", xmin=5.955364, xmax=6.155364, ymin=-Inf, ymax=Inf, alpha=0.2, fill="royalblue")

resLoadASCA[[4]] + annotate("rect", xmin=5.955364, xmax=6.155364, ymin=-Inf, ymax=Inf, alpha=0.2, fill="royalblue") + annotate("rect", xmin=7.458, xmax=7.935, ymin=-Inf, ymax=Inf, alpha=0.2, fill="yellowgreen") + annotate("rect", xmin=3.881, xmax=4.041, ymin=-Inf, ymax=Inf, alpha=0.2, fill="yellowgreen")

resLoadASCA[[5]] + annotate("rect", xmin=5.955364, xmax=6.155364, ymin=-Inf, ymax=Inf, alpha=0.2, fill="royalblue") + annotate("rect", xmin=7.458, xmax=7.935, ymin=-Inf, ymax=Inf, alpha=0.2, fill="yellowgreen") + annotate("rect", xmin=3.881, xmax=4.041, ymin=-Inf, ymax=Inf, alpha=0.2, fill="yellowgreen")

```

### Residuals plot

```{r Plot Residuals}

lmwScorePlot(resASCA, effectNames = "Residuals", color = "Day", shape = "Day", drawShapes = "ellipse")

```

## ASCA-E

The ASCA-E method performs PCAs on the effect matrices then add the residuals. The same functions are used.

```{r ASCAE PCA}
resASCAE = lmwPcaEffects(resLmwEffectMatrices = resLmwEffectMatrices, method="ASCA-E")
```

Contributions and loadings are identical to the ASCA results.

### Scores Plot

```{r ASCAE ScoresXY}
lmwScorePlot(resASCAE, effectNames = "Hippurate", color = "Hippurate", shape = "Hippurate")
lmwScorePlot(resASCAE, effectNames = "Citrate", color = "Citrate", shape = "Citrate")
lmwScorePlot(resASCAE, effectNames = "Time", color = "Time", shape = "Time")
lmwScorePlot(resASCAE, effectNames = "Hippurate:Time", color = "Hippurate", shape = "Time")
```

```{r ASCAE ScoresMatrix}
lmwScoreScatterPlotM(resASCAE,
                     modelAbbrev = TRUE,
                     effectNames = c("Hippurate", "Citrate", "Time",
                                     "Hippurate:Time"),
                     varname.colorup = "Citrate",
                     vec.colorup = c("royalblue","yellowgreen","lightcoral"),
                     varname.colordown  = "Time",
                     vec.colordown = c("cadetblue4","deeppink4"),
                     varname.pchup="Hippurate",
                     vec.pchup = c(4,16,2),
                     varname.pchdown="Time",
                     vec.pchdown = c(1,3), title = "ASCA-E scores scatterplot matrix")
```

## APCA

The APCA method performs PCAs on the effect matrices augmented by the residuals. The same functions are used.

```{r APCA PCA}
resAPCA = lmwPcaEffects(resLmwEffectMatrices = resLmwEffectMatrices, method="APCA")
```

### Contributions

```{r APCA Contrib}
resLmwContributions = lmwContributions(resAPCA)

pander::pander(resLmwContributions$effectTable)
```

### Scores Plot

```{r APCA ScoresXY}
lmwScorePlot(resAPCA, effectNames = "Hippurate", color = "Hippurate", shape = "Hippurate", drawShapes = "ellipse")
lmwScorePlot(resAPCA, effectNames = "Citrate", color = "Citrate", shape = "Citrate")
lmwScorePlot(resAPCA, effectNames = "Time", color = "Time", shape = "Time")
lmwScorePlot(resAPCA, effectNames = "Hippurate:Time", color = "Hippurate", shape = "Time")
```

```{r APCA ScoresMatrix}
lmwScoreScatterPlotM(resAPCA,
                     effectNames = c("Hippurate", "Citrate", "Time",
                                     "Hippurate:Time"),
                     modelAbbrev = TRUE,
                     varname.colorup = "Citrate",
                     vec.colorup = c("royalblue","yellowgreen","lightcoral"),
                     varname.colordown  = "Time",
                     vec.colordown = c("cadetblue4","deeppink4"),
                     varname.pchup="Hippurate",
                     vec.pchup = c(4,16,2),
                     varname.pchdown="Time",
                     vec.pchdown = c(1,3), title = "APCA scores scatterplot matrix")
```

### Loadings plot

```{r APCA loadings}

lmwLoadingPlot(resAPCA, effectNames = c("Hippurate", "Citrate", "Time", "Hippurate:Time"), axes = 1)

```

# Session info
```{r}
sessionInfo()
```

# References
